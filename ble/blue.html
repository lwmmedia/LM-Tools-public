<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BLE Internal Analyzer (Bluefy/iOS)</title>
  <meta name="robots" content="noindex,nofollow" />
  <style>
    body { font-family: -apple-system, system-ui, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    h1 { font-size: 18px; margin: 0 0 6px; }
    h2 { font-size: 14px; margin: 0 0 8px; }
    .muted { color: #666; font-size: 12px; }
    .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin: 10px 0; }
    .card { border:1px solid #e6e6e6; border-radius: 12px; padding: 12px; margin: 12px 0; }
    button { padding: 10px 12px; border: 1px solid #ccc; border-radius: 10px; background: #fff; }
    button:disabled { opacity: .5; }
    select, input { padding: 8px; border-radius: 10px; border:1px solid #ccc; }
    .kv { display:grid; grid-template-columns: 140px 1fr; gap: 6px 10px; font-size: 13px; }
    #log { white-space: pre-wrap; font-family: ui-monospace, Menlo, Consolas, monospace; font-size: 12px; }
    #tree { font-family: ui-monospace, Menlo, Consolas, monospace; font-size: 12px; line-height: 1.35; }
    code { font-family: ui-monospace, Menlo, Consolas, monospace; font-size: 12px; }
    .pill { display:inline-block; padding: 2px 8px; border:1px solid #ddd; border-radius: 999px; font-size: 12px; margin-right: 6px; }
    .hr { height:1px; background:#eee; margin: 10px 0; }
    .btn-s { padding: 6px 10px; font-size: 12px; border-radius: 10px; }
    textarea { width:100%; min-height: 70px; border:1px solid #ccc; border-radius: 10px; padding: 10px; font-family: ui-monospace, Menlo, Consolas, monospace; font-size: 12px; }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    #seenDevices { font-family: ui-monospace, Menlo, Consolas, monospace; font-size: 12px; line-height: 1.35; }
    @media (max-width: 800px) { .grid2 { grid-template-columns: 1fr; } .kv{grid-template-columns:120px 1fr;} }
  </style>
</head>
<body>
  <h1>BLE Internal Analyzer</h1>
  <div class="muted">
    Outil interne : inventaire GATT, lecture/écriture, notifications, profilage, export JSON/CSV.
    (Web Bluetooth requis : Bluefy iOS avec Web Bluetooth actif + page en HTTPS)
  </div>

  <div class="card">
    <div class="row">
      <button id="btnPick">Sélectionner périphérique</button>
      <button id="btnDisconnect" disabled>Déconnecter</button>
      <button id="btnRefresh" disabled>Rafraîchir GATT</button>
      <button id="btnClearLog">Effacer log</button>
      <button id="btnExportJson" disabled>Export JSON</button>
      <button id="btnExportCsv" disabled>Export CSV</button>
    </div>

    <div class="row">
      <span class="pill">Profilage</span>
      <span class="pill">Notifications</span>
      <span class="pill">Dump hex</span>
      <span class="pill">Décodage modulaire</span>
    </div>

    <div class="kv">
      <div class="muted">Périphérique</div><div id="devName">—</div>
      <div class="muted">ID</div><div id="devId">—</div>
      <div class="muted">État</div><div id="devState">Déconnecté</div>
      <div class="muted">Connect t0</div><div id="tConnect">—</div>
      <div class="muted">GATT inventory</div><div id="tInventory">—</div>
      <div class="muted">1ère notif</div><div id="tFirstNotif">—</div>
      <div class="muted">Notif count</div><div id="notifCount">0</div>
    </div>

    <div class="hr"></div>

    <div class="row">
      <div class="muted">Mode sélection</div>
      <select id="mode">
        <option value="acceptAll">acceptAllDevices (picker)</option>
        <option value="battery">Filtre : Battery Service (0x180F)</option>
        <option value="deviceInfo">Filtre : Device Info (0x180A)</option>
        <option value="custom">Filtre : Service UUID custom</option>
      </select>

      <div class="muted">Service UUID custom</div>
      <input id="customSvc" placeholder="ex: 6e400001-b5a3-f393-e0a9-e50e24dcca9e" style="min-width:320px;" />

      <div class="muted">Optional services (CSV UUID)</div>
      <input id="optSvcs" placeholder="battery_service,device_information,..." style="min-width:320px;" />
    </div>
  </div>

  <div class="card">
    <h2>Périphériques présents (session)</h2>
    <div class="muted">Liste des périphériques sélectionnés pendant cette session, avec identifiant et état.</div>
    <div id="seenDevices" class="muted" style="margin-top:8px;">Aucun périphérique sélectionné.</div>
  </div>

  <div class="card">
    <h2>Commandes (lecture / écriture ciblée)</h2>
    <div class="muted">
      Renseignez une caractéristique (UUID) pour agir directement (utile quand l’inventaire est long).
      L’écriture supporte HEX (<code>01 0a ff</code>) ou ASCII (<code>HELLO</code>).
    </div>
    <div class="grid2" style="margin-top:10px;">
      <div>
        <div class="muted">Characteristic UUID</div>
        <input id="cmdCharUuid" placeholder="ex: 00002a19-0000-1000-8000-00805f9b34fb" style="width:100%;" />
        <div class="row">
          <button class="btn-s" id="btnCmdRead" disabled>Lire</button>
          <button class="btn-s" id="btnCmdNotifyOn" disabled>Notif ON</button>
          <button class="btn-s" id="btnCmdNotifyOff" disabled>Notif OFF</button>
        </div>
        <div class="muted" id="cmdOut">Valeur: —</div>
      </div>
      <div>
        <div class="muted">Écriture (HEX ou ASCII)</div>
        <textarea id="cmdWriteData" placeholder="HEX: 01 02 0a ff   |   ASCII: HELLO"></textarea>
        <div class="row">
          <select id="cmdWriteMode">
            <option value="hex">HEX</option>
            <option value="ascii">ASCII</option>
          </select>
          <button class="btn-s" id="btnCmdWrite" disabled>Écrire</button>
          <select id="cmdWriteType">
            <option value="write">write</option>
            <option value="writeWithoutResponse">writeWithoutResponse</option>
          </select>
        </div>
        <div class="muted">Conseil : sur certains firmwares, l’écriture sans réponse est requise.</div>
      </div>
    </div>
  </div>

  <div class="card">
    <h2>Inventaire GATT (tech)</h2>
    <div id="tree" class="muted">Non connecté.</div>
  </div>

  <div class="card">
    <h2>Log</h2>
    <div id="log"></div>
  </div>

  <script type="module">
    import {
      nowIso, msDelta, hexFromBuf, asciiFromBuf, bufFromHex, bufFromAscii,
      shortUuid, propsToText, downloadText, safeReadValue, clampStr,
      csvEscape
    } from './utils.js';

    import { decodeValue } from './parsers.js';
    import { createBleCommandHandlers } from './commands.js';

    const $ = (id) => document.getElementById(id);

    const btnPick = $("btnPick");
    const btnDisconnect = $("btnDisconnect");
    const btnRefresh = $("btnRefresh");
    const btnClearLog = $("btnClearLog");
    const btnExportJson = $("btnExportJson");
    const btnExportCsv = $("btnExportCsv");

    const devName = $("devName");
    const devId = $("devId");
    const devState = $("devState");

    const tConnect = $("tConnect");
    const tInventory = $("tInventory");
    const tFirstNotif = $("tFirstNotif");
    const notifCountEl = $("notifCount");

    const mode = $("mode");
    const customSvc = $("customSvc");
    const optSvcs = $("optSvcs");

    const tree = $("tree");
    const logEl = $("log");
    const seenDevices = $("seenDevices");

    const cmdCharUuid = $("cmdCharUuid");
    const btnCmdRead = $("btnCmdRead");
    const btnCmdNotifyOn = $("btnCmdNotifyOn");
    const btnCmdNotifyOff = $("btnCmdNotifyOff");
    const btnCmdWrite = $("btnCmdWrite");
    const cmdWriteData = $("cmdWriteData");
    const cmdWriteMode = $("cmdWriteMode");
    const cmdWriteType = $("cmdWriteType");
    const cmdOut = $("cmdOut");

    let device = null;
    let server = null;

    // In-memory session
    const session = {
      meta: {
        startedAt: nowIso(),
        userAgent: navigator.userAgent,
        url: location.href,
        note: "BLE Internal Analyzer"
      },
      device: {},
      profiling: {
        connectStartIso: null,
        connectMs: null,
        inventoryMs: null,
        firstNotifyMs: null
      },
      inventory: {
        services: [] // populated after refresh
      },
      events: [], // {ts, lvl, type, ...}
      seenDevices: [] // [{id, name, firstSeen, lastSeen, state}]
    };

    let connectT0 = 0;
    let inventoryT0 = 0;
    let firstNotifySet = false;
    let notifCount = 0;

    const MAX_WRITE_BYTES = 244;

    function uiSetState(s) { devState.textContent = s; }

    function log(lvl, type, obj = {}) {
      const evt = { ts: nowIso(), lvl, type, ...obj };
      session.events.push(evt);

      const line = `[${evt.ts}] ${lvl} ${type} ${obj.msg ? "- " + obj.msg : ""}`.trim();
      logEl.textContent += line + "\n";
      logEl.scrollTop = logEl.scrollHeight;
    }

    function upsertSeenDevice(state) {
      if (!device) return;
      const id = device.id || "—";
      const name = device.name || "(sans nom)";
      const now = nowIso();
      let row = session.seenDevices.find(d => d.id === id);
      if (!row) {
        row = { id, name, firstSeen: now, lastSeen: now, state };
        session.seenDevices.push(row);
      } else {
        row.name = name;
        row.lastSeen = now;
        row.state = state;
      }
      renderSeenDevices();
    }

    function renderSeenDevices() {
      if (!session.seenDevices.length) {
        seenDevices.textContent = "Aucun périphérique sélectionné.";
        return;
      }
      const lines = session.seenDevices.map((d, i) =>
        `${i + 1}. ${d.name} | id=${d.id} | état=${d.state} | vu=${d.lastSeen}`
      );
      seenDevices.textContent = lines.join("\n");
    }

    function enableConnectedUi(connected) {
      btnDisconnect.disabled = !connected;
      btnRefresh.disabled = !connected;
      btnExportJson.disabled = !connected;
      btnExportCsv.disabled = !connected;

      btnCmdRead.disabled = !connected;
      btnCmdNotifyOn.disabled = !connected;
      btnCmdNotifyOff.disabled = !connected;
      btnCmdWrite.disabled = !connected;
    }

    function onDisconnected() {
      uiSetState("Déconnecté");
      enableConnectedUi(false);
      tree.textContent = "Non connecté.";
      upsertSeenDevice("déconnecté");
      log("INFO", "DISCONNECT", { msg: "GATT disconnected" });
    }

    function ensureWebBluetooth() {
      if (!navigator.bluetooth) {
        log("ERROR", "NO_WEB_BLUETOOTH", { msg: "navigator.bluetooth absent (Bluefy/Web Bluetooth non disponible)" });
        alert("Web Bluetooth indisponible dans ce navigateur.");
        return false;
      }
      return true;
    }

    function buildRequestOptions() {
      const optionalServices = [];
      const rawOpt = (optSvcs.value || "").trim();
      if (rawOpt) {
        rawOpt.split(",").map(s => s.trim()).filter(Boolean).forEach(s => optionalServices.push(s));
      } else {
        // defaults
        optionalServices.push("device_information");
        optionalServices.push("battery_service");
      }

      const m = mode.value;
      if (m === "acceptAll") return { acceptAllDevices: true, optionalServices };

      if (m === "battery") return { filters: [{ services: ["battery_service"] }], optionalServices };
      if (m === "deviceInfo") return { filters: [{ services: ["device_information"] }], optionalServices };

      // custom
      const u = (customSvc.value || "").trim();
      if (!u) {
        // fallback : acceptAll
        return { acceptAllDevices: true, optionalServices };
      }
      return { filters: [{ services: [u] }], optionalServices };
    }

    async function pickAndConnect() {
      if (!ensureWebBluetooth()) return;

      session.meta.startedAt = nowIso();
      session.events = [];
      session.inventory.services = [];
      session.device = {};
      session.profiling = { connectStartIso: null, connectMs: null, inventoryMs: null, firstNotifyMs: null };

      firstNotifySet = false;
      notifCount = 0;
      notifCountEl.textContent = "0";
      tFirstNotif.textContent = "—";
      tInventory.textContent = "—";

      const options = buildRequestOptions();
      log("INFO", "REQUEST_DEVICE", { msg: "requestDevice", options });

      device = await navigator.bluetooth.requestDevice(options);

      session.device = {
        name: device.name || "",
        id: device.id || "",
      };

      devName.textContent = device.name || "(sans nom)";
      devId.textContent = device.id || "—";

      device.addEventListener("gattserverdisconnected", onDisconnected);

      uiSetState("Connexion…");
      connectT0 = performance.now();
      session.profiling.connectStartIso = nowIso();

      server = await device.gatt.connect();
      const connectMs = Math.round(performance.now() - connectT0);

      session.profiling.connectMs = connectMs;
      tConnect.textContent = `${connectMs} ms`;
      uiSetState("Connecté");
      enableConnectedUi(true);
      upsertSeenDevice("connecté");

      log("INFO", "CONNECT", { msg: "GATT connected", connectMs });

      await refreshGattInventory();
    }

    async function refreshGattInventory() {
      if (!server?.connected) return;

      inventoryT0 = performance.now();
      log("INFO", "INVENTORY_START", { msg: "Listing primary services" });

      const services = await server.getPrimaryServices();
      const inv = [];

      // Text tree
      const lines = [];
      lines.push(`Device: ${device?.name || "(sans nom)"}  id=${device?.id || "—"}`);
      lines.push(`Services: ${services.length}`);
      lines.push("");

      for (const svc of services) {
        const svcEntry = { uuid: svc.uuid, characteristics: [] };
        lines.push(`SVC ${shortUuid(svc.uuid)}  ${svc.uuid}`);

        let chars = [];
        try {
          chars = await svc.getCharacteristics();
        } catch (e) {
          lines.push(`  ! getCharacteristics failed: ${String(e)}`);
          svcEntry.error = String(e);
          inv.push(svcEntry);
          continue;
        }

        lines.push(`  chars=${chars.length}`);
        for (const ch of chars) {
          const chEntry = {
            uuid: ch.uuid,
            properties: { ...ch.properties },
            descriptors: []
          };

          const propsTxt = propsToText(ch.properties);
          lines.push(`  CH  ${shortUuid(ch.uuid)}  props=[${propsTxt}]`);
          lines.push(`      ${ch.uuid}`);

          // Try descriptors (often restricted)
          try {
            const descs = await ch.getDescriptors();
            lines.push(`      desc=${descs.length}`);
            for (const d of descs) {
              const dEntry = { uuid: d.uuid };
              lines.push(`      DS  ${shortUuid(d.uuid)}  ${d.uuid}`);
              chEntry.descriptors.push(dEntry);
            }
          } catch (e) {
            lines.push(`      desc=? (restricted)`);
          }

          // Best-effort read
          let readBuf = null;
          if (ch.properties.read) {
            readBuf = await safeReadValue(ch);
            if (readBuf) {
              const hx = hexFromBuf(readBuf);
              const asc = asciiFromBuf(readBuf);
              const decoded = decodeValue(svc.uuid, ch.uuid, readBuf);
              chEntry.sample = { hex: hx, ascii: asc, decoded };

              lines.push(`      read: hex=[${clampStr(hx, 120)}] ascii="${clampStr(asc, 80)}"`);
              if (decoded) lines.push(`      dec : ${JSON.stringify(decoded)}`);
              log("INFO", "READ_SAMPLE", {
                msg: `sample read ${ch.uuid}`,
                service: svc.uuid,
                characteristic: ch.uuid,
                hex: hx,
                ascii: asc,
                decoded
              });
            } else {
              lines.push(`      read: (failed)`);
            }
          }

          svcEntry.characteristics.push(chEntry);
        }

        lines.push("");
        inv.push(svcEntry);
      }

      session.inventory.services = inv;

      const inventoryMs = Math.round(performance.now() - inventoryT0);
      session.profiling.inventoryMs = inventoryMs;
      tInventory.textContent = `${inventoryMs} ms`;

      tree.textContent = lines.join("\n");
      log("INFO", "INVENTORY_DONE", { msg: "Inventory complete", services: inv.length, inventoryMs });
    }

    async function disconnect() {
      try {
        if (device?.gatt?.connected) device.gatt.disconnect();
      } catch (e) {
        log("ERROR", "DISCONNECT_ERR", { msg: String(e) });
      }
      onDisconnected();
    }

    const { cmdRead, cmdWrite, cmdNotifyOn, cmdNotifyOff } = createBleCommandHandlers({
      getServer: () => server,
      getCmdCharUuid: () => cmdCharUuid.value.trim(),
      getCmdWriteMode: () => cmdWriteMode.value,
      getCmdWriteType: () => cmdWriteType.value,
      getCmdWriteData: () => cmdWriteData.value || "",
      setCmdOut: (text) => { cmdOut.textContent = text; },
      log,
      decodeValue,
      safeReadValue,
      hexFromBuf,
      asciiFromBuf,
      bufFromHex,
      bufFromAscii,
      clampStr,
      onNotify: ({ svcUuid, chUuid, buf, hx, asc, decoded, size }) => {
        notifCount += 1;
        notifCountEl.textContent = String(notifCount);

        if (!firstNotifySet) {
          firstNotifySet = true;
          const ms = Math.round(performance.now() - connectT0);
          session.profiling.firstNotifyMs = ms;
          tFirstNotif.textContent = `${ms} ms`;
        }

        log("INFO", "NOTIFY", {
          msg: "notification",
          service: svcUuid,
          characteristic: chUuid,
          hex: hx,
          ascii: asc,
          decoded,
          size
        });
        throw new Error("Characteristic introuvable via getCharacteristic (UUID ou droits).");
      })();
    }

    async function cmdRead() {
      if (!server?.connected) return;
      const u = cmdCharUuid.value.trim();
      try {
        const { svc, ch } = await getCharByUuid(u);
        if (!ch.properties.read) throw new Error("Lecture non supportée par cette caractéristique.");
        const buf = await safeReadValue(ch);
        if (!buf) throw new Error("Lecture impossible (droits/erreur).");

        const hx = hexFromBuf(buf);
        const asc = asciiFromBuf(buf);
        const decoded = decodeValue(svc.uuid, ch.uuid, buf);

        cmdOut.textContent = `Valeur: hex=[${hx}] ascii="${asc}"` + (decoded ? ` dec=${JSON.stringify(decoded)}` : "");
        log("INFO", "CMD_READ", { msg: "cmd read", service: svc.uuid, characteristic: ch.uuid, hex: hx, ascii: asc, decoded });
      } catch (e) {
        cmdOut.textContent = `Erreur: ${String(e)}`;
        log("ERROR", "CMD_READ_ERR", { msg: String(e) });
      }
    }

    function ensureWritePayloadSize(buf) {
      if (buf.byteLength === 0) throw new Error("Payload vide: écriture annulée.");
      if (buf.byteLength > MAX_WRITE_BYTES) {
        throw new Error(`Payload trop long (${buf.byteLength} octets, max ${MAX_WRITE_BYTES}).`);
      }
    }

    function confirmWriteIntent({ characteristic, writeType, mode, size }) {
      const ok = confirm(
        `Confirmer l'écriture BLE ?\n` +
        `Characteristic: ${characteristic}\n` +
        `Type: ${writeType}\n` +
        `Mode: ${mode}\n` +
        `Taille: ${size} octet(s)`
      );
      if (!ok) throw new Error("Écriture annulée par l'utilisateur.");
    }

    async function cmdWrite() {
      if (!server?.connected) return;
      const u = cmdCharUuid.value.trim();
      const mode = cmdWriteMode.value;
      const writeType = cmdWriteType.value;
      const data = cmdWriteData.value || "";

      try {
        const { svc, ch } = await getCharByUuid(u);

        if (writeType === "write" && !ch.properties.write) throw new Error("write non supporté.");
        if (writeType === "writeWithoutResponse" && !ch.properties.writeWithoutResponse) throw new Error("writeWithoutResponse non supporté.");

        let buf;
        if (mode === "hex") buf = bufFromHex(data);
        else buf = bufFromAscii(data);

        ensureWritePayloadSize(buf);
        confirmWriteIntent({ characteristic: ch.uuid, writeType, mode, size: buf.byteLength });

        const dv = new DataView(buf);

        if (writeType === "write") await ch.writeValue(dv);
        else await ch.writeValueWithoutResponse(dv);

        cmdOut.textContent = `Écriture OK (${buf.byteLength} octets).`;
        log("INFO", "CMD_WRITE", {
          msg: "cmd write",
          service: svc.uuid,
          characteristic: ch.uuid,
          writeType,
          dataMode: mode,
          size: buf.byteLength,
          hex: hexFromBuf(buf),
          ascii: asciiFromBuf(buf)
        });
      } catch (e) {
        cmdOut.textContent = `Erreur: ${String(e)}`;
        log("ERROR", "CMD_WRITE_ERR", { msg: String(e) });
        alert(`Écriture impossible: ${String(e)}`);
      }
    }

        cmdOut.textContent = `Notif: hex=[${clampStr(hx, 180)}] ascii="${clampStr(asc, 90)}"` + (decoded ? ` dec=${JSON.stringify(decoded)}` : "");
      }
    });

    function exportJson() {
      const data = JSON.stringify(session, null, 2);
      const name = `ble-session-${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
      downloadText(name, data, "application/json");
      log("INFO", "EXPORT_JSON", { msg: "export json", filename: name, bytes: data.length });
    }

    function exportCsv() {
      // Events CSV
      const cols = ["ts","lvl","type","msg","service","characteristic","hex","ascii","decoded","size"];
      const rows = [cols.join(",")];

      for (const e of session.events) {
        const decoded = e.decoded ? JSON.stringify(e.decoded) : "";
        const row = [
          csvEscape(e.ts || ""),
          csvEscape(e.lvl || ""),
          csvEscape(e.type || ""),
          csvEscape(e.msg || ""),
          csvEscape(e.service || ""),
          csvEscape(e.characteristic || ""),
          csvEscape(e.hex || ""),
          csvEscape(e.ascii || ""),
          csvEscape(decoded),
          csvEscape(String(e.size ?? ""))
        ].join(",");
        rows.push(row);
      }

      const data = rows.join("\n");
      const name = `ble-events-${new Date().toISOString().replace(/[:.]/g,'-')}.csv`;
      downloadText(name, data, "text/csv");
      log("INFO", "EXPORT_CSV", { msg: "export csv", filename: name, rows: rows.length });
    }

    // Wire UI
    btnPick.addEventListener("click", async () => {
      try { await pickAndConnect(); }
      catch (e) {
        uiSetState("Déconnecté");
        enableConnectedUi(false);
        log("ERROR", "CONNECT_ERR", { msg: String(e) });
        alert(String(e));
      }
    });

    btnDisconnect.addEventListener("click", disconnect);
    btnRefresh.addEventListener("click", refreshGattInventory);
    btnClearLog.addEventListener("click", () => { logEl.textContent = ""; });

    btnExportJson.addEventListener("click", exportJson);
    btnExportCsv.addEventListener("click", exportCsv);

    btnCmdRead.addEventListener("click", cmdRead);
    btnCmdWrite.addEventListener("click", cmdWrite);
    btnCmdNotifyOn.addEventListener("click", cmdNotifyOn);
    btnCmdNotifyOff.addEventListener("click", cmdNotifyOff);

    // Initial diagnostics
    renderSeenDevices();

    if (!navigator.bluetooth) {
      log("ERROR", "NO_WEB_BLUETOOTH", { msg: "navigator.bluetooth absent. Ouvrir en Bluefy avec Web Bluetooth actif + HTTPS." });
      tree.textContent = "Web Bluetooth indisponible (navigator.bluetooth absent).";
    } else {
      log("INFO", "READY", { msg: "Web Bluetooth détecté. Sélectionnez un périphérique." });
      tree.textContent = "Prêt. Cliquez sur « Sélectionner périphérique ».";
    }
  </script>
</body>
</html>
